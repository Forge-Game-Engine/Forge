"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.backgroundShader = void 0;
exports.backgroundShader = "#version 300 es\n#property name: background.frag\n\nprecision mediump float;\n\nuniform vec2 u_resolution;\nuniform vec4 u_color;\n\n#include <perlinNoise>\n\nout vec4 fragColor;\n\nfloat hash(vec2 p) {\n  // stable 2D hash\n  p = fract(p * vec2(123.34, 456.21));\n  p += dot(p, p + 45.32);\n  return fract(p.x * p.y);\n}\n\nfloat stars(vec2 uv, float density, float rarity, float radius) {\n  vec2 g = uv * density;\n  vec2 grid = floor(g);\n  vec2 cell = fract(g) - 0.5;\n\n  float h = hash(grid);\n\n  // only some cells get stars\n  float exists = step(rarity, h);\n\n  // round star falloff\n  float d = length(cell);\n  float s = smoothstep(radius, 0.0, d) * exists;\n\n  // vary brightness a bit (bigger h -> brighter)\n  float intensity = mix(0.6, 1.4, fract(h * 13.37));\n\n  // tiny twinkle\n  float twinkle = 0.85 + 0.15 * sin(u_time * 3.0 + h * 50.0);\n\n  return s * intensity * twinkle;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n  uv.x *= u_resolution.x / u_resolution.y;\n\n  // background scroll\n  vec2 uvBg = uv + vec2(0.0, u_time * 0.2);\n\n  vec3 layer1 = perlinNoise(uvBg, 3.0, 0.35);\n  vec3 layer2 = perlinNoise(uvBg, 8.0, 1.0);\n  vec3 layer3 = perlinNoise(uvBg, 13.0, 2.0);\n\n  vec3 combined = (layer1 * 0.8 + layer2 * 0.4 + layer3 * 0.2)\n                / (0.8 + 0.4 + 0.2);\n\n  combined = (combined * 0.5 + 0.5) - 0.6;\n\n  vec2 uvStars = uv + vec2(0.0, u_time * 0.03);\n\n  float starLayer1 = stars(uvStars, 130.0, 0.985, 0.3);\n\n  vec2 uv2 = uv * 1.6 + vec2(0.0, u_time * 0.1); \n  float starLayer2 = stars(uv2, 60.0, 0.998, 0.4);            \n\n  vec3 color = combined * u_color.rgb;\n\n  color += starLayer1 + starLayer2;\n\n  fragColor = vec4(color, u_color.a);\n}";
